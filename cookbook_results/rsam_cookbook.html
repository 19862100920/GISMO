
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>RSAM Cookbook</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-03-22"><meta name="DC.source" content="rsam_cookbook.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>RSAM Cookbook</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Short explanation</a></li><li><a href="#2">Longer explanation</a></li><li><a href="#3">History of RSAM</a></li><li><a href="#4">Additional capabilities of GISMO's RSAM class</a></li><li><a href="#5">Computing RSAM from waveform objects</a></li><li><a href="#10">Plotting RSAM objects</a></li><li><a href="#12">Saving RSAM objects</a></li><li><a href="#20">Loading data from a binary "BOB" file</a></li></ul></div><h2>Short explanation<a name="1"></a></h2><p>RSAM is essentially just a downsampled version of continuous seismic data, making it easier to examine long-term trends in the data, e.g. to recognize periods of unrest, episodes of tremor, etc. The properties of a GISMO RSAM object are:</p><div><ul><li>dnum = date/time of time-windows corresponding to each data value, as a          MATLAB datenum.</li><li>data = each data value is the RSAM value for a particular time window</li><li>measure = records which statistic was used. Default "mean", which             implies that each data value is the mean absolute value of the             seismic waveform during the corresponding time window.</li><li>units = records the units that the data is expressed in. Default           counts, which implies uncalibrated units straight out of the           digitizer.</li><li>ChannelTag = records the ChannelTag object corresponding to the time                series expressed by dnum and data. A ChannelTag object                records the network, station, location and channel code.</li><li>snum = the MATLAB datenum corresponding to the start time/date - equal           to the lowest value in dnum.</li><li>enum = the MATLAB datenum corresponding to the end time/date - equal           to the higest value in dnum.</li><li>sampling_interval = the length of the time window for each RSAM data                       sample, in seconds. (Default 60 seconds)</li></ul></div><h2>Longer explanation<a name="2"></a></h2><p>RSAM stands for "Real-time Seismic Amplitude Measurement". An RSAM object is a data type that holds RSAM data. Typically each RSAM value is computed from the raw continuous seismic data like this:</p><div><ol><li>Break the seismic data into non-overlapping time windows (typically   60-second windows).</li><li>Compute the mean. Subtract it from the data. This removes the offset   due to a seismometer not being centred. This process is called   'demeaning'.</li><li>Compute the absolute values of the 'demeaned' data.</li><li>Then compute the mean average of these absolute demeaned data. This   mean value is the RSAM value for that time window.</li></ol></div><h2>History of RSAM<a name="3"></a></h2><p>The RSAM system was originally developed in 1985 by Tom Murray. The purpose was to track the average amplitudes of data from different station-channels over time intervals of 2.56, 60 and 600 seconds, and plot them graphically. Alarms could also be configured to detect events and tremor based on these RSAM values.</p><p>The RSAM system also saved 60-sec values to binary files that could be read by the program "BOB" (also written by Tom Murray). Through the USGS Volcano Disaster Assistance Program, RSAM and BOB became widely used throughout the world at volcano observatories. So there are many of these binary files (which GISMO refers to as "BOB" files) in the archives of volcano observatories. It is important that we can read them. as the raw continuous seismic data was usually not preserved (storage was very expensive until about the year 2000). This can be done with the 'read_bob_file' method of the RSAM class.</p><p>Earthworm, the seismic data acquisition system developed by USGS, also includes modules to compute RSAM values, create RSAM alarms, and save RSAM values to "BOB" files. We want to be able to read these too, and 'read_bob_file' will do this.</p><h2>Additional capabilities of GISMO's RSAM class<a name="4"></a></h2><p>GISMO expands on the traditional definition of RSAM in 3 ways:</p><div><ul><li>Traditional RSAM units are "counts" - the raw digitizer output. GISMO   RSAM objects can have physically meaningful units, e.g. nm / sec. This   is recorded in the "units" property.</li><li>Each RSAM value is traditionally the mean amplitude of the seismic   data within the corresponding time window. But GISMO RSAM objects may   other measurements, such as the maximum amplitude within that time   window, or the root-mean-square value, or the median value. The   'measure' property records which statistic was used.</li><li>The traditional sampling interval (time window length) for recorded   RSAM data is 60 seconds. GISMO RSAM objects may use other sampling   intervals. Common choices are 1 sec, 60 sec, 600 sec, 3600 sec.</li></ul></div><h2>Computing RSAM from waveform objects<a name="5"></a></h2><p>In GISMO, waveform objects are the data type created to hold continuous seismic data. The waveform2rsam method can be used to compute RSAM data from a waveform object.</p><p>First we need to load a waveform object:</p><pre class="codeinput">filepath = fullfile(TESTDATA, <span class="string">'waveform_data'</span>, <span class="string">'REF.EHZ.2009.081'</span>);
ds = datasource(<span class="string">'miniseed'</span>, filepath);
snum = datenum(2009,3,22,0,0,0);
enum = snum + 6/24;
ctag = ChannelTag(<span class="string">''</span>,<span class="string">'REF'</span>,<span class="string">''</span>,<span class="string">'EHZ'</span>);
w = waveform(ds, ctag, snum, enum);
plot(w)
</pre><pre class="codeoutput">ReadMSEEDFast:	/home/t/thompsong/src/GISMO.website/testdata/waveform_data/REF.EHZ.2009.081
</pre><img vspace="5" hspace="5" src="rsam_cookbook_01.png" alt=""> <p>Now compute RSAM data. The default sampling interval is 1 minute, and the default sampling method is "mean".</p><pre class="codeinput">rsamobj1 = waveform2rsam(w)
</pre><pre class="codeoutput">
rsamobj1 = 

  rsam with properties:

                 dnum: [1x360 double]
                 data: [1x360 double]
              measure: 'mean'
      seismogram_type: ''
                units: 'Counts'
                files: ''
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 733854
                 enum: 7.3385e+05
                  sta: {'REF'}
                 chan: {'EHZ'}
    sampling_interval: 60.0000
                stats: [1x1 struct]

</pre><p>This is equivalent to:</p><pre class="codeinput">rsamobj2 = waveform2rsam(w, <span class="string">'mean'</span>, 60.0)
</pre><pre class="codeoutput">
rsamobj2 = 

  rsam with properties:

                 dnum: [1x360 double]
                 data: [1x360 double]
              measure: 'mean'
      seismogram_type: ''
                units: 'Counts'
                files: ''
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 733854
                 enum: 7.3385e+05
                  sta: {'REF'}
                 chan: {'EHZ'}
    sampling_interval: 60.0000
                stats: [1x1 struct]

</pre><p>For "events" it may be more useful to use a finer sampling interval, and record the absolute maximum value (greatest amplitude) of each time window. Here we use a 10-s sampling rate.</p><pre class="codeinput">rsamobj3 = waveform2rsam(w, <span class="string">'max'</span>, 10.0)
</pre><pre class="codeoutput">
rsamobj3 = 

  rsam with properties:

                 dnum: [1x2160 double]
                 data: [1x2160 double]
              measure: 'max'
      seismogram_type: ''
                units: 'Counts'
                files: ''
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 733854
                 enum: 7.3385e+05
                  sta: {'REF'}
                 chan: {'EHZ'}
    sampling_interval: 10.0000
                stats: [1x1 struct]

</pre><p>For "tremor" we want to filter out the "events". If all events are shorter than 30 seconds, then a median filter with a time window of at least 60 seconds should work well. Here we choose a time window of 10 minutes:</p><pre class="codeinput">rsamobj4 = waveform2rsam(w, <span class="string">'median'</span>, 600.0)
</pre><pre class="codeoutput">
rsamobj4 = 

  rsam with properties:

                 dnum: [1x36 double]
                 data: [1x36 double]
              measure: 'median'
      seismogram_type: ''
                units: 'Counts'
                files: ''
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 733854
                 enum: 7.3385e+05
                  sta: {'REF'}
                 chan: {'EHZ'}
    sampling_interval: 600.0000
                stats: [1x1 struct]

</pre><h2>Plotting RSAM objects<a name="10"></a></h2><p>There are two ways to plot RSAM objects. The first is the 'plot' method, which puts all graphs within the same axis:</p><pre class="codeinput">rsamvector = [rsamobj1 rsamobj2 rsamobj3 rsamobj4]
rsamvector.plot();
legend(<span class="string">'1:default'</span>,<span class="string">'2:default2'</span>,<span class="string">'3:max-10s'</span>,<span class="string">'4:median-600s'</span>)
</pre><pre class="codeoutput">
rsamvector = 

  1x4 rsam array with properties:

    dnum
    data
    measure
    seismogram_type
    units
    files
    ChannelTag
    request
    snum
    enum
    sta
    chan
    sampling_interval
    stats

</pre><img vspace="5" hspace="5" src="rsam_cookbook_02.png" alt=""> <p>The second method is 'plot_panels' which puts plots each RSAM object in a different subplot:</p><pre class="codeinput">rsamvector.plot_panels();
</pre><pre class="codeoutput">
ans = 

  Figure (3) with properties:

      Number: 3
        Name: ''
       Color: [0.9400 0.9400 0.9400]
    Position: [677 555 560 420]
       Units: 'pixels'

  Use GET to show all properties

</pre><img vspace="5" hspace="5" src="rsam_cookbook_03.png" alt=""> <h2>Saving RSAM objects<a name="12"></a></h2><p>RSAM objects can be saved to text files, and to binary (bob) files.</p><p><b>TEXT FILE</b></p><pre class="codeinput">rsamobj3.save_to_text_file(<span class="string">'REF.EHZ.10s.max.txt'</span>);
</pre><p>The first few lines of this file will look like:</p><pre>   733854.00000000	2009-03-22 00:00:00.000	6.988e+03
   733854.00011574	2009-03-22 00:00:10.000	3.535e+02
   733854.00023148	2009-03-22 00:00:20.000	2.503e+02
   733854.00034722	2009-03-22 00:00:30.000	6.211e+02
   733854.00046296	2009-03-22 00:00:40.000	1.129e+03
   733854.00057870	2009-03-22 00:00:50.000	9.490e+02</pre><p>The first column is the dnum, the second column expresses the dnum as a human-readable yyyy-mm-dd HH:MM:SS.FFF string, and the third column is the RSAM data value. The sampling interval in 10-seconds in this case.</p><p><b>BINARY BOB FILE</b></p><pre class="codeinput">rsamobj3.save_to_bob_file(<span class="string">'REF.EHZ.10s.max.bob'</span>);
</pre><pre class="codeoutput">Saving to REF.EHZ.10s.max.bob
</pre><p>Generally it will be more useful to use a file pattern, where the following substitutions will be made:   SSSS - station   CCC - channel   YYYY - year   MMMM - measure</p><p>This way multiple rsam objects can be saved using a simialr filename pattern, e.g.</p><pre class="codeinput">rsamvector.save_to_bob_file(<span class="string">'SSSS.CCC.10s.MMMM.bob'</span>);
</pre><pre class="codeoutput">Saving to REF.EHZ.10s.mean.bob

ans =

     []

Saving to REF.EHZ.10s.mean.bob

ans =

     []

Saving to REF.EHZ.10s.max.bob
Saving to REF.EHZ.10s.median.bob
</pre><p>-------------------------------------------------------------------</p><p>To proceed further with this tutorial, you must have the GISMO test dataset available.</p><pre class="codeinput"><span class="keyword">if</span> ~is_testdata_setup()
    error(<span class="string">'GISMO test data must be accessible to proceed further with this tutorial'</span>)
<span class="keyword">end</span>
</pre><h2>Loading data from a binary "BOB" file<a name="20"></a></h2><p>The original RSAM system recorded data in binary files that could be read by a program called "BOB". Earthworm also has a module to record RSAM data in BOB compatible files. Each BOB file holds the RSAM data for one station-channel, per year.</p><p>For one station we can use an explicit path:</p><pre class="codeinput">dp = fullfile(TESTDATA,<span class="string">'rsam'</span>,<span class="string">'MCPZ1996.DAT'</span>);
s = rsam.read_bob_file(dp, <span class="string">'snum'</span>, datenum(1996,12,1), <span class="keyword">...</span>
  <span class="string">'enum'</span>, datenum(1996,12,31), <span class="string">'sta'</span>, <span class="string">'MCPZ'</span>, <span class="string">'units'</span>, <span class="string">'Counts'</span>)
s.plot();
</pre><pre class="codeoutput">Looking for file: /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1996.DAT - found
Loading data from /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1996.DAT, position 482400 to 525600 of 527040
mean of data loaded is 5.249939e+01

s = 

  rsam with properties:

                 dnum: [1x43201 double]
                 data: [1x43201 double]
              measure: ''
      seismogram_type: ''
                units: 'Counts'
                files: [1x1 struct]
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 729360
                 enum: 729390
                  sta: {'MCPZ'}
                 chan: {''}
    sampling_interval: 60.0000
                stats: [1x1 struct]

</pre><img vspace="5" hspace="5" src="rsam_cookbook_04.png" alt=""> <p>If we want to read across year boundaries, or read all the files in a directory, we can use a file pattern. For example to read all files with that begin with a 4-character station code, followed by a 4-character year, and an extension of '.DAT', use the following file pattern:</p><pre class="codeinput">dp = fullfile(TESTDATA,<span class="string">'rsam'</span>,<span class="string">'SSSSYYYY.DAT'</span>); <span class="comment">%SSSS means station, YYYY means year</span>
s = rsam.read_bob_file(dp, <span class="string">'snum'</span>, datenum(1996,12,1), <span class="keyword">...</span>
      <span class="string">'enum'</span>, datenum(1997,2,1), <span class="string">'sta'</span>, <span class="string">'MCPZ'</span>, <span class="string">'units'</span>, <span class="string">'Counts'</span>)
s.plot();
</pre><pre class="codeoutput">Looking for file: /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1996.DAT - found
Looking for file: /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1997.DAT - found
Loading data from /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1996.DAT, position 482400 to 5.270400e+05 of 527040
mean of data loaded is 5.240957e+01
Loading data from /home/t/thompsong/src/GISMO.website/testdata/rsam/MCPZ1997.DAT, position 0 to 44640 of 525600
mean of data loaded is 6.196203e+01

s = 

  rsam with properties:

                 dnum: [1x89281 double]
                 data: [1x89281 double]
              measure: ''
      seismogram_type: ''
                units: 'Counts'
                files: [1x2 struct]
           ChannelTag: [1x1 ChannelTag]
              request: [1x1 struct]
                 snum: 729360
                 enum: 729422
                  sta: {'MCPZ'}
                 chan: {''}
    sampling_interval: 60.0000
                stats: [1x1 struct]

</pre><img vspace="5" hspace="5" src="rsam_cookbook_05.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% RSAM Cookbook

%% Short explanation
% RSAM is essentially just a downsampled version of continuous seismic
% data, making it easier to examine long-term trends in the data, e.g. to
% recognize periods of unrest, episodes of tremor, etc. The properties of a
% GISMO RSAM object are:
% 
%
% 
% * dnum = date/time of time-windows corresponding to each data value, as a
%          MATLAB datenum.
% * data = each data value is the RSAM value for a particular time window
% * measure = records which statistic was used. Default "mean", which
%             implies that each data value is the mean absolute value of the
%             seismic waveform during the corresponding time window.
% * units = records the units that the data is expressed in. Default
%           counts, which implies uncalibrated units straight out of the
%           digitizer.
% * ChannelTag = records the ChannelTag object corresponding to the time 
%                series expressed by dnum and data. A ChannelTag object
%                records the network, station, location and channel code.
% * snum = the MATLAB datenum corresponding to the start time/date - equal
%           to the lowest value in dnum.
% * enum = the MATLAB datenum corresponding to the end time/date - equal
%           to the higest value in dnum.
% * sampling_interval = the length of the time window for each RSAM data
%                       sample, in seconds. (Default 60 seconds)
%
%
%% Longer explanation
% RSAM stands for "Real-time Seismic Amplitude Measurement". An RSAM object
% is a data type that holds RSAM data. Typically each RSAM value is
% computed from the raw continuous seismic data like this:
% 
% # Break the seismic data into non-overlapping time windows (typically
%   60-second windows).
% # Compute the mean. Subtract it from the data. This removes the offset
%   due to a seismometer not being centred. This process is called
%   'demeaning'.
% # Compute the absolute values of the 'demeaned' data. 
% # Then compute the mean average of these absolute demeaned data. This
%   mean value is the RSAM value for that time window.
%
%% History of RSAM
% The RSAM system was originally developed in 1985 by Tom Murray. The
% purpose was to track the average amplitudes of data from different
% station-channels over time intervals of 2.56, 60 and 600 seconds, and
% plot them graphically. Alarms could also be configured to detect events
% and tremor based on these RSAM values.
%
% The RSAM system also saved 60-sec values to binary files that could be
% read by the program "BOB" (also written by Tom Murray).
% Through the USGS Volcano Disaster Assistance Program, RSAM and BOB became
% widely used throughout the world at volcano observatories. So there are
% many of these binary files (which GISMO refers to as "BOB" files) in the
% archives of volcano observatories. It is important that we can read them.
% as the raw continuous seismic data was usually not preserved (storage was
% very expensive until about the year 2000). This can be done with the
% 'read_bob_file' method of the RSAM class.
%
% Earthworm, the seismic data acquisition system developed by USGS, also
% includes modules to compute RSAM values, create RSAM alarms, and save
% RSAM values to "BOB" files. We want to be able to read these too, and
% 'read_bob_file' will do this.
%
%% Additional capabilities of GISMO's RSAM class
% GISMO expands on the traditional definition of RSAM in 3 ways:
% 
% 
% * Traditional RSAM units are "counts" - the raw digitizer output. GISMO
%   RSAM objects can have physically meaningful units, e.g. nm / sec. This
%   is recorded in the "units" property.
% * Each RSAM value is traditionally the mean amplitude of the seismic
%   data within the corresponding time window. But GISMO RSAM objects may
%   other measurements, such as the maximum amplitude within that time
%   window, or the root-mean-square value, or the median value. The
%   'measure' property records which statistic was used.
% * The traditional sampling interval (time window length) for recorded
%   RSAM data is 60 seconds. GISMO RSAM objects may use other sampling
%   intervals. Common choices are 1 sec, 60 sec, 600 sec, 3600 sec.


%% Computing RSAM from waveform objects
%
% In GISMO, waveform objects are the data type created to hold continuous
% seismic data. The waveform2rsam method can be used to compute RSAM data
% from a waveform object. 
%
% First we need to load a waveform object:
filepath = fullfile(TESTDATA, 'waveform_data', 'REF.EHZ.2009.081');
ds = datasource('miniseed', filepath);
snum = datenum(2009,3,22,0,0,0);
enum = snum + 6/24;
ctag = ChannelTag('','REF','','EHZ');
w = waveform(ds, ctag, snum, enum);
plot(w)

%%
% Now compute RSAM data. The default sampling interval is 1 minute, and 
% the default sampling method is "mean". 
rsamobj1 = waveform2rsam(w)

%%
% This is equivalent to:
rsamobj2 = waveform2rsam(w, 'mean', 60.0)

%%
% For "events" it may be more useful to use a finer sampling interval, and
% record the absolute maximum value (greatest amplitude) of each time
% window. Here we use a 10-s sampling rate.
rsamobj3 = waveform2rsam(w, 'max', 10.0)

%%
% For "tremor" we want to filter out the "events". If all events are
% shorter than 30 seconds, then a median filter with a time window of at
% least 60 seconds should work well. Here we choose a time window of 10
% minutes:
rsamobj4 = waveform2rsam(w, 'median', 600.0)

%% Plotting RSAM objects
% There are two ways to plot RSAM objects. The first is the 'plot' method,
% which puts all graphs within the same axis:
rsamvector = [rsamobj1 rsamobj2 rsamobj3 rsamobj4]
rsamvector.plot();
legend('1:default','2:default2','3:max-10s','4:median-600s')
%%
% The second method is 'plot_panels' which puts plots each RSAM object in a
% different subplot:
rsamvector.plot_panels();


%% Saving RSAM objects
% RSAM objects can be saved to text files, and to binary (bob) files.
%

%%
% *TEXT FILE*
rsamobj3.save_to_text_file('REF.EHZ.10s.max.txt');
%%
% The first few lines of this file will look like:
%%
%
%     733854.00000000	2009-03-22 00:00:00.000	6.988e+03
%     733854.00011574	2009-03-22 00:00:10.000	3.535e+02
%     733854.00023148	2009-03-22 00:00:20.000	2.503e+02
%     733854.00034722	2009-03-22 00:00:30.000	6.211e+02
%     733854.00046296	2009-03-22 00:00:40.000	1.129e+03
%     733854.00057870	2009-03-22 00:00:50.000	9.490e+02
%
%%
% The first column is the dnum, the second column expresses the dnum as a
% human-readable yyyy-mm-dd HH:MM:SS.FFF string, and the third column is
% the RSAM data value. The sampling interval in 10-seconds in this case.
%
%%
% *BINARY BOB FILE*
rsamobj3.save_to_bob_file('REF.EHZ.10s.max.bob');

%%
% Generally it will be more useful to use a file pattern, where the
% following substitutions will be made:
%   SSSS - station
%   CCC - channel
%   YYYY - year
%   MMMM - measure
% 
% This way multiple rsam objects can be saved using a simialr filename
% pattern, e.g.
rsamvector.save_to_bob_file('SSSS.CCC.10s.MMMM.bob');


%% 
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%
% To proceed further with this tutorial, you must have the GISMO test
% dataset available. 
if ~is_testdata_setup()
    error('GISMO test data must be accessible to proceed further with this tutorial')
end

%% Loading data from a binary "BOB" file
% The original RSAM system recorded data in binary files that could be read
% by a program called "BOB". Earthworm also has a module to record RSAM
% data in BOB compatible files.
% Each BOB file holds the RSAM data for one station-channel, per year.

%%
% For one station we can use an explicit path:
dp = fullfile(TESTDATA,'rsam','MCPZ1996.DAT');
s = rsam.read_bob_file(dp, 'snum', datenum(1996,12,1), ...
  'enum', datenum(1996,12,31), 'sta', 'MCPZ', 'units', 'Counts')
s.plot();

%%
% If we want to read across year boundaries, or read all the files in a
% directory, we can use a file pattern. For example to read all files with
% that begin with a 4-character station code, followed by a 4-character
% year, and an extension of '.DAT', use the following file pattern:
dp = fullfile(TESTDATA,'rsam','SSSSYYYY.DAT'); %SSSS means station, YYYY means year
s = rsam.read_bob_file(dp, 'snum', datenum(1996,12,1), ...
      'enum', datenum(1997,2,1), 'sta', 'MCPZ', 'units', 'Counts')
s.plot();


##### SOURCE END #####
--></body></html>